PIPELINE OVERVIEW:

    (Beware, currently there's a fairly loose mapping between pipeline
    stages and corresponding RTL files.)


    IF1 IF2 IF3 DE EX      [EX2] WB
                   ME1 ME2 [ME3]

    IF1 - pc calculation / handle restarts and kill

    IF2 - begin I$ tag lookup

    IF3 - determine I$ way and begin I$ access

    DE  - begin register file lookup, partial decoding

    EX  - bypass and alu computations
    ME1 - begin D$ tag lookup

    ME2 - determine way and start D$ access

    WB  - load subword extraction & sign extension, and
          register file write-back.

    It's possible that we get rid of IF1. If we switch to a directly
    mapped I$ then we can get rid of IF2 also.

    EX3/ME3 is under consideration but the bypass network is
    terrifying.

    As of 2007-12-13, the subword extraction & sign extension is the
    critical path.


TODO

* Write a PSRAM controller (for the LPRP).

* Change makeconfig.sh to instead parse config.h (which should now be
  written by hand). This is in preparation for moving many more
  configurable features to the config.h

* Port to Xilinx' ML401 and one of the Spartan-3 starter kits

* Implement DIV

* Move all architectual state updates to the latest stage that can
  flush the pipe (and thus annul the updates).

  Doing this requires one of two approaches: The simplest is to move
  their implementation to stage ME, that is, give them an additional
  cycle of latency, and add the hazard checking.

  The more advanced approach is to maintain two copies of the state:
  the speculative in the earlier state and the committed state in ME
  (or WB). Pipe restarts will copy the committed state back into the
  speculative state, while normal (and valid) instructions will update
  the commited state just like the register file.

  Ex:                               LO
                                SPEC  COMMITTED
    ld   $r3, ($r0)              old    old
    mtlo $r2                     $r2    old
    <exception from ld detected> old    old

  Ex:                               LO
                                SPEC  COMMITTED
    mtlo $r2                     $r2    old
    mflo $r3                     $r2    old
    addi $r4,$r3,2               $r2    $r2

  (These are poorly chosen examples as mtlo is idempotent and does not
  strictly speaking need this until we implement memory exceptions,
  but imagine something like mul or other that can change the state in
  a different way each time.)

* Trap on ADD[I] and SUB overflow

* Separate the memory bus from the peripheral bus.

  Things gets interesting with peripherals that need DMA-like access
  to memory, such as video interfaces.

  A consequence would be that Flash etc would be on the peripheral
  bus, so if we wish to cache this, we'd have to distinguish IO from
  uncachable.

* Merge fpgaMMIX and YARI, incl. the Avalon-like interconnect (for
  peripherals). Automate the generation of the interconnection.

* Implement interrupt support

* Implement I$ and D$ flushing!

* I$ locking under sw control

* (PERF) Sign-extension and shifting in ME is the critical
  path.

  Add an ME2 stage to handle that. Restart on LB/LBU/LH/LHU-use
  hazards (LW keeps its 1-cycle latency, but LB/LBU/LH/LHU are now
  2-cycle). Add an extra level of bypass.

  This opens the door to EX2 and EX3, useful for multiply and shifts
  especially.

* (PERF) Make the video interface much more efficient and have all major
  parameters settable from IO space (where it makes sense). Lot's of
  MSB counters as these are cheap and fast. Example:

     if (x[X_MSB])
       x <= video_registers_xwidth;
     else
       x <= x - 1;



OTHER:
* Improve documentation, notably how to build and port the RTL

* Restructure the RTL so that it matches the actual pipeline better
  and all stage_XX outputs are guaranteed to be registers.

* (PERF) Investigate the cycle penalty of going from the current three
  stages for IF to just two stages.

* (PERF) Make I$ cache words wider and use the extra bits for, say:
  - Poor-mans two bit branch prediction
  - Pre-decode key instruction, such as branches and jumps
  - Pre calculate part of the destination of branches/jumps
  All aimed at issueing control flow instructions (sometimes
  speculatively) from DE, saving one precious pipeline bubble.

* (PERF) Change the bypass mux from the current priority encoded mux
  to a regular mux and precompute the index in DE.

* (PERF) Better cache replacement strategy (at least use pseudo
  random, but investigate how hard pseudo-LRU would be to implement)

* Support more of CP2 and move it to a later stage (cf. correct
  handling of pipeline flushes)

* Trap on illegal instructions

* (PERF) Conditional support for pipeline stalls (need to examine the
  cycle-time penalty and the cost-benefit)

* Better portability to other devices incl. Xilinx

* More complete R3000 support, incl. trapping ADD/SUB on overflow

* Make the simulator more complete, incl. support for CP2 features
  like virtual memory etc.

* The I$ tags are very inefficient four 20x32 arrays. Investigate

  - Making the tag(s) single port arrays (thus two in a ram block)

  - Making a single combined 80x32 array - all tags are read at the
    same time anyway and four 20-bit 4-to-1 muxes can handle the writing

  - Using smaller blocks, say 32-byte instead of 128-byte (tags are
    cheap). (4Kb = 512 B = 128 W) Faster fill and better
    utilization. [DID THAT]


* Reconsider cosimulating against gxemul. I'd obviously need to fill
  in the gaps where gxemul takes a shortcut (such as providing a real
  firmware). Q: how to deal with the IO?

* Make the RTL simulation snapshotable and restartable. Only way to
  deal with the 250 inst/sec performance. (This is a generalization of

    "Find a way to preload the RTL simulated SRAM (loading the kernel
     with the bootloader under RTL simulation takes *WAY* too
     long).").


* Write the dummy firmware expected by the linux kernel for the
  DECstation. (See gxemul/src/machines/machine_pmax.c and
  gxemul/src/promemul/dec_prom.c)

* Add a small ROM to the RTL implementation (maybe)

* Matching IO behaviour like I do now is unsustainable. As a general
  principle, while cosimulating, higher level models could take the IO
  events from the lower levels (which can ultimately be the running
  FPGA).





Old stuff below pending clean up .....

FEATURES
0. Get GDBstub running for loading and starting programs [DONE]

   0a. Solve the bootstrapping problem: how to populate the data
       segment from the bootprom (preloaded cache from which stage ME
       can't access data). [DONE]

   0b. Implement I$ cache flushing.  Limited isasim support.  Full
       RTL.

1. Debugging with the GDB stub:

   1a. Interrupts support
       ISASIM: Implement the CP0 registers and UART interrupts
       RTL:    -- " -- + bind a Dev board button to break

   1b. Get single stepping working (GDB stub work mostly).





2. Implement MUL* and DIV*.
3. SDRAM support.

4. Better infrastructure for peripherals
5. CF support.
6. Ethernet.
7. PS/2 Keyboard
8. Sound output.
9. Flash RAM support.
A. PS/2 Mouse.

B. Ports to ML401, XSA-100, ...

C. (MAYBE) Exploit the R-modify-W mode of the SRAM to create a "smart"
   framebuffer.  Probably only worthwhile if the SRAM is dedicated to
   the framebuffer.

PERFORMANCE
- Make the SRAM interface much faster (fewer cycles)

- (ADV) Rethink the internal memory bus.  Notably, it's silly for the
  I$ to be able to access the (slow) peripheral bus.

- Make the I$ filling faster (fewer cycles).

- (ADV) Don't block while filling the I$.  Not obvious how to achieve
  this without inserting logic between the I$ ram and the decode
  stage.

- (ADV) Non-blocking loads.  For a single outstanding load it's
  actually not too hard, but we'll have to stall the pipe if the
  write-back stage is busy when the memory comes back to us.  Multiple
  outstanding are probably not worth the trouble.

OTHER

0. Make a "normal.ld" linker script that places programs in SRAM +
   write a little boot loader that copies it from the boot rom to
   sram. (MAYBE)

4. Consistent naming convention (FOREVER ONGOING)

    * nets are prefixed with the module that produces them (mostly
      already the case).

    * nets include an underscore `_' after the module prefix if
      they're one cycle delayed from the source registers.  Nearly all
      clocked registers applies.

  + Convert more assigns to un-clocked registers (always @*'s) -- it's
    easier to read (DEBATABLE)

  + Minimize the amount of logic after registers (D'OH!)

