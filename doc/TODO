Before YARI 0.1-RC2: Improve documentation
Before YARI 0.2: Interrupts and exceptions!
Before YARI 0.3: Improve the SOC generator and add more peripherals
Before YARI 0.5: Improve the cycle time

Before YARI 0.9: CP2 support, supervisor mode, trap illegal instructions
Before YARI 1.0: Boot Linux!

PIPELINE OVERVIEW:

    (Beware, currently there's a fairly loose mapping between pipeline
    stages and corresponding RTL files.)


    IF1 IF2 IF3 DE EX      [EX2] WB
                   ME1 ME2 [ME3]

    IF1 - pc calculation / handle restarts and kill

    IF2 - begin I$ tag lookup

    IF3 - determine I$ way and begin I$ access

    DE  - begin register file lookup, partial decoding

    EX  - bypass and alu computations
    ME1 - begin D$ tag lookup

    ME2 - determine way and start D$ access

    WB  - load subword extraction & sign extension, and
          register file write-back.

    It's possible that we get rid of IF1. If we switch to a directly
    mapped I$ then we can get rid of IF2 also.

    EX3/ME3 is under consideration but the bypass network is
    terrifying.

    As of 2007-12-13, the subword extraction & sign extension is the
    critical path.


TODO

* Write a PSRAM controller (for the LPRP).

* We're dancing on eggshells; instructions modifying non-register
  state in EX wouldn't behave correctly when flushed from ME! (eg, lw
  $3, ($4); mthi $5). The only reason there are no known bugs is
  because currently the only flushes from ME are restarts.

  If ME is ever taught to trap (misalignment, segmentation violation,
  permission problems, page miss, etc), then this will require
  immediate attention.


  Fixing this requires moving all architectual state updates to the
  latest stage that can flush the pipe (and thus annul the updates).

  Doing this requires one of two approaches: The simplest is to move
  their implementation to stage ME, that is, give them an additional
  cycle of latency, and add the hazard checking.

  The more advanced approach is to maintain two copies of the state:
  the speculative in the earlier state and the committed state in ME
  (or WB). Pipe restarts will copy the committed state back into the
  speculative state, while normal (and valid) instructions will update
  the commited state just like the register file.

  Ex:                               LO
                                SPEC  COMMITTED
    ld   $r3, ($r0)              old    old
    mtlo $r2                     $r2    old
    <exception from ld detected> old    old

  Ex:                               LO
                                SPEC  COMMITTED
    mtlo $r2                     $r2    old
    mflo $r3                     $r2    old
    addi $r4,$r3,2               $r2    $r2

  (These are poorly chosen examples as mtlo is idempotent and does not
  strictly speaking need this until we implement memory exceptions,
  but imagine something like mul or other that can change the state in
  a different way each time.)

* Improve cycle time; attack the current critical path which is in
  ME. First try switching from a tag-sequental cache to the more
  conventional way select (using a 32-bit 4-mux). This gives us
  another stage to do the load alignment and sign-extension.

* Integrate testall.S into tinymon.c

* Change makeconfig.sh to instead parse config.h (which should now be
  written by hand). This is in preparation for moving many more
  configurable features to the config.h

* Implement I$ flushing!

* Merge fpgaMMIX and YARI, incl. the Avalon-like interconnect (for
  peripherals). Automate the generation of the interconnection.

* Implement interrupt support

* Port to Xilinx' ML401 and one of the Spartan-3 starter kits

* Trap on ADD[I] and SUB overflow

* Implement D$ flushing!

* I$ locking under sw control

* (PERF) Sign-extension and shifting in ME is the critical
  path.

  Add an ME2 stage to handle that. Restart on LB/LBU/LH/LHU-use
  hazards (LW keeps its 1-cycle latency, but LB/LBU/LH/LHU are now
  2-cycle). Add an extra level of bypass.

  This opens the door to EX2 and EX3, useful for multiply and shifts
  especially.

* (PERF) Make the video interface much more efficient and have all major
  parameters settable from IO space (where it makes sense). Lot's of
  MSB counters as these are cheap and fast. Example:

     if (x[X_MSB])
       x <= video_registers_xwidth;
     else
       x <= x - 1;



OTHER:
* Collect interesting workloads (SPECint, EEMBC, MiBench, ...)

* Dynamically collect detailed statistics

  - for each restart cause count the number of restart and number of
    cycles lost to it

  - for each stage count the number of valid instructions (to generate
    a temperature strip of which stages are hot)

  - (Optionally simulator only) Distances between the address
    generation and the using load instruction, the load instruction
    and the corresponding use.

  - Bypass utilization staticstics

* Improve documentation, notably how to build and port the RTL

* Restructure the RTL so that it matches the actual pipeline better
  and all stage_XX outputs are guaranteed to be registers.

* (PERF) Investigate the cycle penalty of going from the current three
  stages for IF to just two stages.

* (PERF) Make I$ cache words wider and use the extra bits for, say:
  - Poor-mans two bit branch prediction
  - Pre-decode key instruction, such as branches and jumps
  - Pre calculate part of the destination of branches/jumps
  All aimed at issueing control flow instructions (sometimes
  speculatively) from DE, saving one precious pipeline bubble.

* (PERF) Change the bypass mux from the current priority encoded mux
  to a regular mux and precompute the index in DE.

* (PERF) Better cache replacement strategy (at least use pseudo
  random, but investigate how hard pseudo-LRU would be to implement)
  Done for D$, but not yet for I$ (cache locking is an issue).

* Support more of CP2 and move it to a later stage (cf. correct
  handling of pipeline flushes)

* Trap on illegal instructions

* (PERF) Conditional support for pipeline stalls (need to examine the
  cycle-time penalty and the cost-benefit)

* More complete R3000 support

* Make the simulator more complete, incl. support for CP2 features
  like virtual memory etc.

* The I$ tags are very inefficient four 20x32 arrays. Investigate

  - Making the tag(s) single port arrays (thus two in a ram block)

  - Making a single combined 80x32 array - all tags are read at the
    same time anyway and four 20-bit 4-to-1 muxes can handle the writing

  - Using smaller blocks, say 32-byte instead of 128-byte (tags are
    cheap). (4Kb = 512 B = 128 W) Faster fill and better
    utilization. [DID THAT]


* Reconsider cosimulating against gxemul. I'd obviously need to fill
  in the gaps where gxemul takes a shortcut (such as providing a real
  firmware). Q: how to deal with the IO?

* Make the RTL simulation snapshotable and restartable. Only way to
  deal with the 250 inst/sec performance. (This is a generalization of

* Write the dummy firmware expected by the linux kernel for the
  DECstation. (See gxemul/src/machines/machine_pmax.c and
  gxemul/src/promemul/dec_prom.c)

* Add a small ROM to the RTL implementation (maybe)

* (PERF) IO load performance could be dramatically sped up if we can
  require that peripherals can respond with zero latency. This is
  probably not very hard for a small system, but it's a strong
  constraint.

  The current cost is so high because we have to restart the load
  (just like with a D$ miss). If we could stall the cost would be
  lower, but stalling is way too costly this late in the
  pipeline. Besides, does the cost of IO loads really matter that
  much?



Old stuff below pending clean up .....

FEATURES
1. Debugging with the GDB stub:

   1a. Interrupts support
       ISASIM: Implement the CP0 registers and UART interrupts
       RTL:    -- " -- + bind a Dev board button to break

   1b. Get single stepping working (GDB stub work mostly).

3. SDRAM support.

4. Better infrastructure for peripherals
5. CF support.
6. Ethernet.
7. PS/2 Keyboard
8. Sound output.
9. Flash RAM support.
A. PS/2 Mouse.

PERFORMANCE
- (ADV) Don't block while filling the I$.  Not obvious how to achieve
  this without inserting logic between the I$ ram and the decode
  stage.

- (ADV) Non-blocking loads.  For a single outstanding load it's
  actually not too hard, but we'll have to stall the pipe if the
  write-back stage is busy when the memory comes back to us.  Multiple
  outstanding are probably not worth the trouble.

OTHER

4. Consistent naming convention (FOREVER ONGOING)

    * nets are prefixed with the module that produces them (mostly
      already the case).

    * nets include an underscore `_' after the module prefix if
      they're one cycle delayed from the source registers.  Nearly all
      clocked registers applies.

  + Convert more assigns to un-clocked registers (always @*'s) -- it's
    easier to read (DEBATABLE)
